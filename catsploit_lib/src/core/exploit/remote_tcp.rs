use std::{error::Error, net::TcpStream, time::Duration};

use crate::core::opt::Opt;

pub struct RemoteTcp {
    pub rhost: String,
    pub rport: String,
    pub read_timeout: Option<Duration>,
    pub write_timeout: Option<Duration>,
}

impl RemoteTcp {
    pub fn connect(&self) -> Result<TcpStream, Box<dyn Error>> {
        let stream = TcpStream::connect(format!("{}:{}", self.rhost, self.rport))?;
        stream.set_read_timeout(self.read_timeout)?;
        stream.set_write_timeout(self.write_timeout)?;
        Ok(stream)
    }

    pub fn custom_connect(&self, rhost: &str, rport: &str) -> Result<TcpStream, Box<dyn Error>> {
        let stream = TcpStream::connect(format!("{}:{}", rhost, rport))?;
        stream.set_read_timeout(self.read_timeout)?;
        stream.set_write_timeout(self.write_timeout)?;
        Ok(stream)
    }

    pub fn opts() -> Vec<Opt> {
        let mut opts: Vec<Opt> = Vec::new();
        opts.push(Opt {
            name: "RHOST".to_string(),
            description: "Remote/Target host".to_string(),
            default_value: None,
        });
        opts.push(Opt {
            name: "RPORT".to_string(),
            description: "Remote/Target port".to_string(),
            default_value: None,
        });
        opts.push(Opt {
            name: "READ_TIMEOUT".to_string(),
            description: "Seconds to wait when reading from client stream before timing out"
                .to_string(),
            default_value: Some("60".to_string()),
        });
        opts.push(Opt {
            name: "WRITE_TIMEOUT".to_string(),
            description: "Seconds to wait when writing from client stream before timing out"
                .to_string(),
            default_value: Some("60".to_string()),
        });
        opts
    }
}
