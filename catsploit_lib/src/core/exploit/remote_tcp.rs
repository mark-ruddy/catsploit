use log::info;
use std::{error::Error, net::TcpStream, time::Duration};

use crate::core::opt::Opt;

pub struct RemoteTcp {
    pub rhost: Option<String>,
    pub rport: Option<String>,
    pub read_timeout: Option<Duration>,
    pub write_timeout: Option<Duration>,
}

impl Default for RemoteTcp {
    fn default() -> RemoteTcp {
        RemoteTcp {
            rhost: None,
            rport: None,
            read_timeout: Some(Duration::from_secs(60)),
            write_timeout: Some(Duration::from_secs(60)),
        }
    }
}

impl RemoteTcp {
    pub fn connect(&self) -> Result<TcpStream, Box<dyn Error>> {
        let addr = format!(
            "{}:{}",
            self.rhost.clone().ok_or("RHOST value must be set")?,
            self.rport.clone().ok_or("RPORT value must be set")?,
        );
        info!("Attempting connection to {}", addr);
        let stream = TcpStream::connect(addr)?;
        stream.set_read_timeout(self.read_timeout)?;
        stream.set_write_timeout(self.write_timeout)?;
        Ok(stream)
    }

    pub fn custom_connect(&self, rhost: &str, rport: &str) -> Result<TcpStream, Box<dyn Error>> {
        let stream = TcpStream::connect(format!("{}:{}", rhost, rport))?;
        stream.set_read_timeout(self.read_timeout)?;
        stream.set_write_timeout(self.write_timeout)?;
        Ok(stream)
    }

    pub fn opts() -> Vec<Opt> {
        vec![
            Opt {
                name: "RHOST".to_string(),
                description: "Remote/Target host".to_string(),
                default_value: None,
                value: None,
            },
            Opt {
                name: "RPORT".to_string(),
                description: "Remote/Target port".to_string(),
                default_value: None,
                value: None,
            },
            Opt {
                name: "READ_TIMEOUT".to_string(),
                description: "Seconds to wait when reading from client stream before timing out"
                    .to_string(),
                default_value: Some("60".to_string()),
                value: Some("60".to_string()),
            },
            Opt {
                name: "WRITE_TIMEOUT".to_string(),
                description: "Seconds to wait when writing from client stream before timing out"
                    .to_string(),
                default_value: Some("60".to_string()),
                value: Some("60".to_string()),
            },
        ]
    }
}

macro_rules! apply_opts {
    ($self:ident, $opts:expr) => {
        for opt in $opts {
            match opt.name.as_str() {
                "RHOST" => $self.remote_tcp.rhost = opt.value,
                "RPORT" => $self.remote_tcp.rport = opt.value,
                "READ_TIMEOUT" => {
                    $self.remote_tcp.read_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                "WRITE_TIMEOUT" => {
                    $self.remote_tcp.write_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                _ => (),
            }
        }
    };
}
pub(crate) use apply_opts;

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{Read, Write};
    use std::net::TcpListener;
    use std::thread;

    const HOST: &str = "127.0.0.1";
    const PORT_ONE: &str = "40348";
    const PORT_TWO: &str = "40349";

    fn setup_test_server(port: &str) {
        let addr = format!("{}:{}", HOST, port);
        let listener = TcpListener::bind(&addr).unwrap();
        for stream in listener.incoming() {
            let mut stream = stream.unwrap();
            stream.write_all("test worked!".as_bytes()).unwrap();
            stream.shutdown(std::net::Shutdown::Write).unwrap();
            return;
        }
    }

    #[test]
    fn test_connect() {
        let server_thread = thread::spawn(|| {
            setup_test_server(PORT_ONE);
        });

        let client_thread = thread::spawn(|| {
            let mut remote_tcp = RemoteTcp::default();
            remote_tcp.rhost = Some(HOST.to_string());
            remote_tcp.rport = Some(PORT_ONE.to_string());
            let mut stream = remote_tcp.connect().unwrap();

            let mut stream_output = String::new();
            stream.read_to_string(&mut stream_output).unwrap();
            assert_eq!(stream_output, "test worked!")
        });

        server_thread.join().unwrap();
        client_thread.join().unwrap();
    }

    #[test]
    fn test_custom_connect() {
        let server_thread = thread::spawn(|| {
            setup_test_server(PORT_TWO);
        });

        let client_thread = thread::spawn(|| {
            let remote_tcp = RemoteTcp::default();
            let mut stream = remote_tcp.custom_connect(HOST, PORT_TWO).unwrap();

            let mut stream_output = String::new();
            stream.read_to_string(&mut stream_output).unwrap();
            assert_eq!(stream_output, "test worked!")
        });

        server_thread.join().unwrap();
        client_thread.join().unwrap();
    }
}
