use std::{error::Error, fmt};

use super::opt::Opt;

pub mod remote_tcp;

pub struct Info {
    pub descriptive_name: String,
    pub module_path: String,
    pub disclosure_date: String,
    pub ranking: String,
    pub kind: String,
    pub description: String,
    pub license: Option<String>,
    pub author: Option<Vec<String>>,
    pub references: Option<Vec<String>>,
    pub platform: Option<Vec<String>>,
}

#[derive(Debug)]
pub enum Ranking {
    /// The exploit will never crash the service and will work on common platforms and versions
    Excellent,
    /// The exploit will work on most platforms and versions and is unlikely to crash the service
    High,
    /// The exploit generally works, but may fail on certain platforms and versions
    Average,
    /// The exploit has less than a 50% chance of working for common platforms
    Low,
}

impl fmt::Display for Ranking {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(self, f)
    }
}

#[derive(Debug)]
pub enum Kind {
    Remote,
    Local,
    Multiple,
}

impl fmt::Display for Kind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(self, f)
    }
}

pub struct PayloadCompat {
    pub reverse: bool,
    pub tunnel: bool,
}

impl Default for PayloadCompat {
    fn default() -> PayloadCompat {
        PayloadCompat {
            reverse: true,
            tunnel: false,
        }
    }
}

pub trait Exploit {
    // TODO: learn how this sized works fundamentally
    fn default() -> Self
    where
        Self: Sized;

    fn kind(&self) -> Kind {
        Kind::Multiple
    }

    fn ranking(&self) -> Ranking {
        Ranking::Average
    }

    fn payload_compat(&self) -> PayloadCompat {
        PayloadCompat::default()
    }

    fn info(&self) -> Info;

    // fn exploit(&self) -> Result<(), Box<dyn Error>>;
    fn exploit(&self) -> Result<(), Box<dyn Error>>;

    fn opts(&self) -> Vec<Opt>;

    fn apply_opts(&mut self, opts: Vec<Opt>) -> Result<(), Box<dyn Error>>;
}
